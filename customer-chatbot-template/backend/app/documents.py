"""
Document Metadata Registry

This module maintains metadata about documents in your knowledge base.
It provides utilities for looking up documents by ID, filename, or text patterns.

IMPORTANT: This file is AUTO-GENERATED by scripts/setup-vector-store.py
Do not edit manually unless you understand the document matching system.

CUSTOMIZATION:
- Run 'python scripts/setup-vector-store.py' to regenerate this file
- Or manually add DocumentMetadata entries following the pattern below
- Ensure filenames match exactly what was uploaded to the Vector Store
"""
from __future__ import annotations

from dataclasses import asdict, dataclass
from pathlib import Path
from typing import Iterable


def _normalise(value: str) -> str:
    """Normalize string for matching (lowercase, trimmed)."""
    return value.strip().lower()


def _slugify(value: str) -> str:
    """Convert string to alphanumeric-only slug for fuzzy matching."""
    return "".join(ch for ch in value.lower() if ch.isalnum())


@dataclass(frozen=True, slots=True)
class DocumentMetadata:
    """
    Metadata for a single document in the knowledge base.

    Attributes:
        id: Unique identifier (used in API responses)
        filename: Exact filename as uploaded to Vector Store (for citation matching)
        title: Human-readable title (displayed in UI)
        description: Brief description of document contents (optional, shown in UI)
    """
    id: str
    filename: str
    title: str
    description: str | None = None

    @property
    def stem(self) -> str:
        """Filename without extension (e.g., 'document.pdf' -> 'document')."""
        return Path(self.filename).stem


# ==============================================================================
# DOCUMENT REGISTRY
# ==============================================================================
# TODO: Replace this example data with your actual documents
# Run 'python scripts/setup-vector-store.py' to auto-generate this section

DOCUMENTS: tuple[DocumentMetadata, ...] = (
    # Example document - replace with your own
    DocumentMetadata(
        id="example_doc",
        filename="example_document.pdf",
        title="Example Document",
        description="This is a placeholder. Replace with your actual documents.",
    ),
    # Add more documents here, or use the setup script to auto-generate
)

# ==============================================================================
# DOCUMENT LOOKUP INDICES
# ==============================================================================
# These dictionaries enable fast document lookups by various keys
# They are automatically built from the DOCUMENTS tuple above

DOCUMENTS_BY_ID: dict[str, DocumentMetadata] = {
    doc.id: doc for doc in DOCUMENTS
}

DOCUMENTS_BY_FILENAME: dict[str, DocumentMetadata] = {
    _normalise(doc.filename): doc for doc in DOCUMENTS
}

DOCUMENTS_BY_STEM: dict[str, DocumentMetadata] = {
    _normalise(doc.stem): doc for doc in DOCUMENTS
}

# Build a fuzzy matching index using slugified versions of all text fields
DOCUMENTS_BY_SLUG: dict[str, DocumentMetadata] = {}
for document in DOCUMENTS:
    for candidate in {
        document.id,
        document.filename,
        document.stem,
        document.title,
        document.description or "",
    }:
        if candidate:
            DOCUMENTS_BY_SLUG.setdefault(_slugify(candidate), document)


# ==============================================================================
# UTILITY FUNCTIONS
# ==============================================================================

def as_dicts(documents: Iterable[DocumentMetadata]) -> list[dict[str, str | None]]:
    """
    Convert document metadata objects to dictionaries for JSON serialization.

    Args:
        documents: Iterable of DocumentMetadata objects

    Returns:
        List of dictionaries suitable for JSON responses
    """
    return [asdict(document) for document in documents]


def find_document(query: str) -> DocumentMetadata | None:
    """
    Find a document by trying multiple matching strategies.

    Tries in order:
    1. Exact ID match
    2. Exact filename match (case-insensitive)
    3. Filename stem match (without extension)
    4. Fuzzy slug match (alphanumeric only)

    Args:
        query: Search string (ID, filename, or partial text)

    Returns:
        DocumentMetadata if found, None otherwise
    """
    # Try exact ID
    if query in DOCUMENTS_BY_ID:
        return DOCUMENTS_BY_ID[query]

    # Try normalized filename
    normalized = _normalise(query)
    if normalized in DOCUMENTS_BY_FILENAME:
        return DOCUMENTS_BY_FILENAME[normalized]

    # Try filename stem
    if normalized in DOCUMENTS_BY_STEM:
        return DOCUMENTS_BY_STEM[normalized]

    # Try fuzzy slug matching
    slug = _slugify(query)
    if slug in DOCUMENTS_BY_SLUG:
        return DOCUMENTS_BY_SLUG[slug]

    return None


__all__ = [
    "DOCUMENTS",
    "DOCUMENTS_BY_FILENAME",
    "DOCUMENTS_BY_ID",
    "DOCUMENTS_BY_STEM",
    "DOCUMENTS_BY_SLUG",
    "DocumentMetadata",
    "as_dicts",
    "find_document",
]
